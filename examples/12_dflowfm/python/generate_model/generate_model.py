#!/usr/bin/env python
"""
Generate input files for a 2D D-Flow FM inundation model.

Required source data are raster and polyline files, which will be
converted into the following model input files:
   * Unstructured grid file *_net.nc (uniform or refined).
   * Bathymetry information on that grid.
   * Enclosure polygon as dry area.
   * Initial water levels as polygons.
   * Fixed weirs enclosing regions of fixed water level ('peilgebieden').
   * Quasi 1D channels as a gullies file.
   * Rasters for: Manning's roughness, infiltration capacity.
See the configuration section in this Python file for the required
source data.

"""
# $Id$

__author__ = "Arthur van Dam"
__organization__ = "Deltares"
__copyright__ = "Copyright 2017, Deltares"
__license__ = "AGPL"
__version__ = "1.0"
__maintainer__ = "Arthur van Dam"
__contact__ = "arthur.vandam@deltares.nl"
__status__ = "Production"

import os
import errno
import sys
from math import *
from shutil import move, copy
import mako.template
import mako.lookup
import subprocess
from optparse import OptionParser


# == User Environment Configuration ==

# D-Flow FM location: path to your dir where dflowfm-cli.exe resides:
dflowfmroot    = r'd:\dam_ar\dflowfm_releases\current'
dflowfm        = dflowfmroot+r'\dflowfm-cli.exe'

# GDAL location (download from: http://www.gdal.org/)
gdal_translate = r'c:\Program Files\GDAL\gdal_translate.exe'
gdal_calc      = r'c:\Program Files\GDAL\gdal_calc.py'

# output dir
outputdir      = r'model_generated_ref8t2/'

# Model identifier (just for some file names):
mdident        = 'groesbeek'

# input dir for several GIS-based input files:
gisdir         = r'1135/'

# Model enclosure polygon (used to determine grid extent)
encpolfile     = gisdir+r'aw_buf_pli.pli'

# Input bathymetry data
demfile        = gisdir+r'resampled/aw_ahn_res_asc.asc'

# bed roughness input
frictfile      = gisdir+r'resampled/ruw_m_asc.asc'

# infiltration capacity input
infiltcapfile  = gisdir+r'resampled/bof_res_asc.asc'

# Peilgebieden (for conversion to initial water levels and fixed weirs)
peilfile       = gisdir+r'peil_pli.pliz'

# Gullies: for 1D/polyline-based channel flooding thresholds on 2D grid cells
gulliesfile    = gisdir+r'waterl_inte_pliz.pliz'

# Initial conditions
dwlevstreef = -0.1

# Uniform grid dimensions
dx=8.0
dy=dx

# Grid refinement settings:
refinementfile = gisdir+r'resampled/aw_refi_es_asc.asc'
dxmax=8.0
dxmin=2.0
refmin = 1       # Don't change: should be the smallest (finest) value in the aw_refi_es_asc.asc.
dorefine = False
dorefine = True  # Comment this to force uniform grid resolution.

# Spatial interpolation method for demfile -> grid
# 5: triangular linear interpolation, 6: cell averaging
dem_intp_method = 6
# AVERAGINGTYPE (ONLY WHEN METHOD=6)
#         =1  : SIMPLE AVERAGING
#         =2  : NEAREST NEIGHBOUR
#         =3  : MAX (HIGHEST)
#         =4  : MIN (LOWEST)
#         =5  : INVERSE WEIGHTED DISTANCE-AVERAGE
#         =6  : MINABS
#         =7  : KDTREE (LIKE 1, BUT FAST AVERAGING)
dem_avg_type = 1
bedlevtype = 1 # 1: tile depths on cells, via autogenerated .xyz files (recommended), 3: on corners zk, via autogenerated *_zk_net.nc.


# == Internal Config ==
skipgrid = False
#skipgrid = True

# == Utility functions ==
def mkdir_p(path):
   """Create a directory tree if it does not exist yet."""
   if path == '':
      return

   try:
      os.makedirs(path)
   except OSError as exc:  # Python >2.5
      if exc.errno == errno.EEXIST and os.path.isdir(path):
         pass
      else:
         raise


def docopy(srcfile, destfile):
   """Copy a file to a new destination path.
   
   The target directory tree will automatically be created if it does
   not exist yet.
   """
   mkdir_p(os.path.dirname(destfile))
   copy(srcfile, destfile)


def pol2boundingbox(polfilename, dryareafile):
   """Return the bounding box coordinates for an enclosure polygon.
   
   The bounding box is returned as [xmin, xmax, ymin, ymax].
   As a side effect, a dry area file (*.pol) is writte with the
   required third column containing -1 values, to crop the outer grid
   parts.
   """
   fdry = open(dryareafile,'w')
   with open(polfilename, 'rb') as inf:
      # First skip comment headers
      while True:
         line = inf.readline()
         if not line.startswith(('#', '*')):
            break
      polname = line

      fdry.write(polname.strip() + '\n')

      # the row/columncount line
      line = inf.readline()
      [nrows, ncols] = map(lambda v: int(v), line.split())
      fdry.write('%d %d\n' % (nrows, 3))

      # Now ready for reading all x,y data:
      xmin =  float("inf")
      xmax = -float("inf")
      ymin =  float("inf")
      ymax = -float("inf")
      for line in inf:
         [x, y] = map(lambda v: float(v), line.split())
         xmin = min(x, xmin)
         xmax = max(x, xmax)
         ymin = min(y, ymin)
         ymax = max(y, ymax)
         fdry.write('%.6f %.6f %d\n' % (x, y, -1))

      fdry.close()

   return [xmin, xmax, ymin, ymax]


def gen_mdu_from_template(mdufilename, **variables):
   """Generate an MDU file from the template, using passed variables.
   
   A template MDU file should reside inside the templates directory.
   It can contain ${varname} entries, which can be passed from the
   call site inside the **variables input argument.
   """
   templatedir = 'templates'
   templatename = 'model.tpl.mdu'

   lookup = mako.lookup.TemplateLookup(directories=templatedir, module_directory='/tmp/mako_modules')

   mdutemplate = lookup.get_template(templatename)

   with open(mdufilename, 'wb') as f:
      # You can use all the local variables in the templates
      rendered = mdutemplate.render(**variables)
      # print rendered
      print('Writing ' + mdufilename + '...')
      #print(rendered)
      f.write(rendered)


def generate_model(opts, args):
   """Generate a full set of model input files.
   
   Called from main, receiving command line arguments via OptionParser.
   """
   # == Startup ==
   mkdir_p(outputdir)

   ## 1. grid generation
   print ('== Determining model extent from enclosure polygon =========')

   dryareafile = mdident + '_dryareas.pol'
   [x0, x1, y0, y1] = pol2boundingbox(encpolfile, outputdir + dryareafile)

   print ('== Grid extent based on enclosure polygon:')
   print ('== [xmin, xmax, ymin, ymax] = [%.6f, %.6f, %.6f, %.6f]' % (x0, x1, y0, y1))

   if dorefine:
      dx = dxmax
      dy = dx

   ncols = int(round((x1-x0)/dx +0.5))
   nrows = int(round((y1-y0)/dy +0.5))
   # basename for _net.nc file (without extension), used below.
   netfilebase = mdident+'_unif%d' % dx
   netfile = netfilebase +'_net.nc'

   print ('')
   print ('== Generating uniform grid =================================')
   if not skipgrid and (not os.path.isfile(netfile) or opts.overwrite):
      print('dflowfm-cli.exe --gridgen:x0=%.6f:y0=%.6f:dx=%g:dy=%g:ncols=%d:nrows=%d' % (x0, y0, dx, dy, ncols, nrows))
      os.system(dflowfm+r' --gridgen:x0=%.6f:y0=%.6f:dx=%g:dy=%g:ncols=%d:nrows=%d' % (x0, y0, dx, dy, ncols, nrows))

      move('out_net.nc', netfile)


   ## 1b. grid refinement
   print ('')
   print ('== Local refinement of grid ================================')

   # Renumber refinement factor file (with 1,2,3,.. values) into a 'Courant depth' file, with values (2^(k-1))^2) (i.e., 1, 4, 16, ...).
   iext = refinementfile.rfind('.asc')
   refinementrenumfiletif = refinementfile[0:iext] + '_renum.tif'
   refinementrenumfile    = refinementfile[0:iext] + '_renum.asc'
   if dorefine and (not os.path.isfile(refinementrenumfile) or opts.overwrite):
      print(' '.join(map(str, [sys.executable, gdal_calc, '-A', refinementfile, '--outfile='+refinementrenumfiletif, '--calc=2**(2*(A-1))', '--NoDataValue=-9999', '--overwrite', '--creation-option=COMPRESS=DEFLATE'])))
      subprocess.call([sys.executable, gdal_calc, '-A', refinementfile, '--outfile='+refinementrenumfiletif, '--calc=2**(2*(A-1))', '--NoDataValue=-9999', '--overwrite', '--creation-option=COMPRESS=DEFLATE'], shell=True)

      print(' '.join(map(str, [gdal_translate, '-of AAIGrid', refinementrenumfiletif, refinementrenumfile])))
      subprocess.call([gdal_translate, '-of', 'AAIGrid', refinementrenumfiletif, refinementrenumfile], shell=True)

   # basename for _net.nc file (without extension), used below.
   if dorefine:
      coarsenetfile = netfile
      netfilebase = mdident+'_ref%dt%d' % (dxmax, dxmin)
      netfile = netfilebase+'_net.nc'
      if not skipgrid and (not os.path.isfile(netfile) or opts.overwrite):
         dtmax = ceil(1000 * dxmin / sqrt(9.81 * refmin))/1000
         print('dflowfm-cli.exe %s %s --refine:hmin=%d:dtmax=%.3f:connect=1:outsidecell=1' % (coarsenetfile, refinementrenumfile, dxmin, dtmax))
         os.system(dflowfm+r' %s %s --refine:hmin=%d:dtmax=%.3f:connect=1:outsidecell=1' % (coarsenetfile, refinementrenumfile, dxmin, dtmax))

         move('out_net.nc', netfile)

   ## 2. bathymetry interpolation
   print ('')
   print ('== Interpolating DEM onto grid =============================')

   # Prepare ext file
   extfile = mdident + '_bathy.ext'
   f = open(extfile,'wb')

   f.write( \
     'QUANTITY=bedlevel\n' \
   + 'FILENAME='+demfile+'\n' \
   + 'FILETYPE=4\n' \
   + ('METHOD=%d\n' % (dem_intp_method))
   + 'OPERAND=O\n')
   if dem_intp_method == 6:
      f.write( \
         ('AVERAGINGTYPE=%d\n' % (dem_avg_type)) \
      +  'PERCENTILEMINMAX=50\n' \
         )


   f.close()

   mdufile = mdident + '_bathy.mdu'
   f = open(mdufile,'wb')

   f.write( \
     '[model]\n' \
   + 'Program = D-Flow FM\n' \
   + '\n' \
   + '[geometry]\n' \
   + 'NetFile = '+netfile+'\n' \
   + ('BedlevType = %d\n' % (bedlevtype)) \
   + ('' if bedlevtype >= 3 else 'Conveyance2D = -1\n') \
   + '\n' \
   + '[external forcing]\n' \
   + 'ExtForceFile = ' + extfile + '\n' \
   + '\n' \
   + '[output]\n' \
   + 'WriteDFMinterpretedvalues = 1\n')

   f.close()

   if bedlevtype >= 3:
      netfile_wbed = netfilebase+'_zk_net.nc'
   else:
      netfile_wbed = netfile
      blxyzfile = netfilebase+'_bl.xyz'

   if not skipgrid and (not os.path.isfile(outputdir + netfile_wbed) \
                        or opts.overwrite):
      print('dflowfm-cli.exe --savenet '+mdufile)
      os.system(dflowfm+r' --savenet '+mdufile)

      if bedlevtype >= 3: # corners zk: interpolated bathy included in _net.nc file.
         move('DFM_interpreted_network_'+mdident+'_bathy_net.nc', outputdir + netfile_wbed)
      else:               # centers bl: interpolated bathy included in separate .xyz file
         _, demfileonly = os.path.split(demfile)
         demfilebase, _ = os.path.splitext(demfileonly)
         move('DFM_interpreted_values_'+demfilebase+'.xyz', outputdir + blxyzfile)
         copy(netfile, outputdir + netfile_wbed)

   # 3a. Custom parts in ext file
   print ('')
   print ('== Inserting user-defined ext-file entries =================')

   # ext file: Prepare ext file for writing several blocks in code below
   extfile = mdident + '.ext'
   if (not os.path.isfile(extfile) or opts.overwrite):
      fext = open(outputdir + extfile,'wb')

      # ext file: Copy-paste all user-defined ext entries in the output ext file.
      # Also copy all forcing data files into outputdir.
      with open(r'templates/externalforcing.tpl.ext', 'rb') as inext:

         while True: # Read all lines
            line = inext.readline()
            if line is None or line == '':
               break # EOF
            fext.write(line)

            if line.startswith('FILENAME='):
               [_, forcefile] = line.split('=')
               forcefile = forcefile.strip()
               docopy(forcefile, outputdir + forcefile)


   # 3b. Standard/generated parts in ext file
   print ('')
   print ('== Inserting standard ext-file entries =====================')

   if (not os.path.isfile(extfile) or opts.overwrite):
      # ext file: bed levels (only in case of tile depths)
      if bedlevtype == 1: # tile depths on centres: precomputed above, now put in final model files.
         fext.write( \
           'QUANTITY=bedlevel\n' \
         + 'FILENAME='+blxyzfile+'\n' \
         + 'FILETYPE=7\n' \
         + 'METHOD=5\n' \
         + 'OPERAND=O\n' \
         + '\n')


      # ext file: bed roughness
      docopy(frictfile, outputdir + frictfile)

      fext.write( \
        'QUANTITY=frictioncoefficient\n' \
      + 'FILENAME='+frictfile+'\n' \
      + 'FILETYPE=4\n' \
      + 'METHOD=5\n' \
      + 'OPERAND=O\n' \
      + '\n')


      # ext file: infiltrationcapacity
      docopy(infiltcapfile, outputdir + infiltcapfile)

      fext.write( \
        'QUANTITY=infiltrationcapacity\n' \
      + 'FILENAME='+infiltcapfile+'\n' \
      + 'FILETYPE=4\n' \
      + 'METHOD=5\n' \
      + 'OPERAND=O\n' \
      + '\n')

   ## 3. Peilgebieden conversion (to initial water levels and fixed weirs)
   print ('')
   print ('== Incorporating peilgebieden ==============================')

   fxwfile = peilfile
   if (not os.path.isfile(outputdir + fxwfile) or opts.overwrite):
      docopy(peilfile, outputdir + fxwfile)

   if (not os.path.isfile(extfile) or opts.overwrite):
      with open(peilfile, 'rb') as inf:

         while True: # Read all polygons in file
            # First skip comment headers
            while True:
               line = inf.readline()
               if not line or not line.strip():
                  break
               if not line.startswith(('#', '*')):
                  break

            if line is None or not line.strip():
               break # EOF

            polname = line
            line = inf.readline()
            [nrows, ncols] = map(lambda v: int(v), line.split())

            print('Reading %s with %d rows...' % (polname.strip(), nrows))

            s1polfile = 'iniwaterlevel_'+polname.strip()+'.pol'
            fpol = open(outputdir + s1polfile,'w')

            fpol.write( \
              polname \
            + '%d %d\n' % (nrows, ncols) \
            )
            for irow in range(nrows):
               line = inf.readline()
               fpol.write(line.strip()+'\n')

            fpol.close()

            [x, y, z] = map(lambda v: float(v), line.split())
            fext.write( \
              'QUANTITY=initialwaterlevel\n' \
            + 'FILENAME='+s1polfile+'\n' \
            + 'FILETYPE=10\n' \
            + 'METHOD=4\n' \
            + 'OPERAND=O\n' \
            + 'VALUE=%g\n' % (z + dwlevstreef) \
            + '\n')

      fext.close()

   mdufile = outputdir + mdident + '.mdu'

   if (not os.path.isfile(outputdir + gulliesfile) or opts.overwrite):
      docopy(gulliesfile, outputdir + gulliesfile)

   print ('')
   print ('== Combining all generated model input into MDU ============')
   if (not os.path.isfile(mdufile) or opts.overwrite):
      mduvars = {
         'NetFile'      : netfile_wbed,
         'FixedWeirFile': fxwfile,
         'DryPointsFile': dryareafile,
         'GulliesFile'  : gulliesfile,
         'ExtForceFile' : extfile
         }

      gen_mdu_from_template(mdufile, **mduvars)

   return

################################################################
def main():
   usage = "usage: "+sys.executable+" %prog --[no]overwrite"
   parser = OptionParser(usage)

   # define options
   parser.add_option("--overwrite", dest="overwrite", action="store_true", default=True, help="Regenerate complete model and overwrite any existing files.")
   parser.add_option("--nooverwrite", dest="overwrite", action="store_false", help="Keep any existing previously generated files.")

   (opts, args) = parser.parse_args()

   generate_model(opts, args)

if __name__ == "__main__":
    main()

